レポート2B

@@@ 1810678 山田朔也 (個人作業)

選択した課題1: 演習1_a
 配列の最大値を求める関数int iarray_max(int *a, int n)を作成する
 また、そのテストケースも作成する

方針1:
 受け取った配列の最初の要素を暫定の最大値として、全探査を行い、
 最初の値よりも大きい値を検出した際に再代入するようにして最大値を探査する。
 テストケースに関しては、既存のものに加え、全部の要素が一致する場合と要素数が一つの場合の
 2つを追加した。

コード1: プログラム一式(動くものを貼ること)
 ----------------------------------------------------------
 #include <stdio.h>
 // your iarray_max here
 /*===========================================================*
   受けとった配列とその要素数から、配列の最大値を返す関数
   引数として配列の最初のアドレスと、配列の要素数を受け取る
   int型で最大値を戻り値として返している
  *===========================================================*/
 int iarray_max(int *a, int n) {
   int max = a[0];
   for(int i = 0; i < n; i++) {
     if(a[i] > max) {
       max = a[i];
     }
   }
   return max;
 }

 void expect_int(int i1, int i2, char *msg) {
   printf("%s %d:%d %s\n", (i1==i2)?"OK":"NG", i1, i2, msg);
 }

 int main(void) {
   int a[] = {9,0,0,1,2,3}, b[] = {-1,-3,-2,-4,-1}, c[] = {1,1,1,1,1}, d[] = {1};
   expect_int(iarray_max(a, 6), 9, "9 0 0 1 2 3");
   expect_int(iarray_max(a+1, 5), 3, "0 0 1 2 3");
   expect_int(iarray_max(b, 5), -1, "-1 -3 -2 -4 -1");
   expect_int(iarray_max(c, 5), 1, "1 1 1 1 1");
   expect_int(iarray_max(d, 1), 1, "1");
   return 0;
 }
 ----------------------------------------------------------

実行例1:
 ----------------------------------------------------------
 OK 9:9 9 0 0 1 2 3
 OK 3:3 0 0 1 2 3
 OK -1:-1 -1 -3 -2 -4 -1
 OK 1:1 1 1 1 1 1
 OK 1:1 1
 ----------------------------------------------------------

解説1:
 コメントにおおよその仕様は記述した。またアルゴリズムに関しては方針と一致している。
 変数maxが最大値を保存するものとなっている。

考察1:
 テストケースを増やして、様々なパターンを考えることで、関数の仕様を厳密にすることができ、
 予期せぬ引数の渡し方にも対応することができることが理解できた。

選択した課題2: 演習2_b
 一つの列を受け取り、その内容を逆順にした列を返す関数を作成する。
 また、その単体テストも作成する。

方針2:
 配列をmallocを使って作成する関数「ivec_new」を使用して作成する。
 次に、その作成された配列に逆順に受け取った配列の要素を代入していく。
 最後に、作成した配列の先頭のポインタを返すように作成するものとする。
 また、受け取る配列の先頭要素は、データが何個入っているかを記述するようにしている。

コード2:
 ----------------------------------------------------------
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>

 void iarray_read(int *a, int n) {
   for(int i = 0; i < n; ++i) {
     printf("%d> ", i+1); scanf("%d", a+i);
   }
 }

 bool iarray_equal(int *a, int *b, int n) {
   for(int i = 0; i < n; ++i) {
     if(a[i] != b[i]) {return false;}
   }
   return true;
 }

 void iarray_print(int *a, int n) {
   for(int i = 0; i < n; ++i) { printf(" %2d", a[i]); }
   printf("\n");
 }

 void expect_iarray(int *a, int *b, int n, char *msg) {
   printf("%s %s\n", iarray_equal(a, b, n)?"OK":"NG", msg);
   iarray_print(a, n); iarray_print(b, n);
 }

 int *ivec_new(int size) {
   int *a = (int*)malloc((size+1) * sizeof(int));
   a[0] = size; return a;
 }

 void ivec_read(int *a) { iarray_read(a+1, a[0]); }

 void ivec_print(int *a) { iarray_print(a+1, a[0]); }

 int *ivec_concat(int *a, int *b) {
   int *c = ivec_new(a[0]+b[0]);
   for(int i = 1; i <= a[0]; ++i) { c[i] = a[i]; }
   for(int i = 1; i <= b[0]; ++i) { c[i + a[0]] = b[i]; }
   return c;
 }

 int *ivec_reverse(int *a) {
   int *b = ivec_new(a[0]);
   for(int i = 0; i < a[0]; i++) {
     b[i + 1] = a[a[0] - i];
   }
   return b;
 }

 int main(void) {
   int a[] = {3,1,2,3}, b[] = {3,3,2,1}, c[] = {1,1}, d[] = {1,1};
   int *p = ivec_reverse(a);
   int *q = ivec_reverse(c);
   expect_iarray(p, b, 4, "{1,2,3} -> {3,2,1}");
   expect_iarray(q, d, 2, "{1} -> {1}");
   return 0;
 }
 ----------------------------------------------------------

実行例2:
 ----------------------------------------------------------
 OK {1,2,3} -> {3,2,1}
  3  3  2  1
  3  3  2  1
 OK {1} -> {1}
  1  1
  1  1
 ----------------------------------------------------------

解説2:
 基本的には方針通りに作成した。また、この関数は先頭に配列の要素数を記述してあるものにしか
 対応していない。

考察2:
 mallocを利用することで配列を安全に使用できることができるのだと感じた。
 なぜならば、これを利用しなければメモリのオーバーランが頻発し、想定外の値を代入したり、
 下手をすればコンピュータ自体に深刻な問題を起こしかねない自体に遭遇しかねないからである。

アンケート:
 Q1.アドレス、ポインタを使うプログラムで注意すべきことは何だと思いますか。
  A1.オーバーランをしないように、常に気をつけるべきだと感じた。
 Q2.ここまでのところで、プログラムを作るときに重要だが自分で身に付いていないと思うことは何ですか。
  A2.タイピング速度が圧倒的に遅いため、これはどうにかしないといけないと感じている。
 Q3.リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。
  A3.特になし。
