レポート11A

@@@ 1810678 山田朔也 (個人作業)

選択した課題: 演習4
    クイックソートを実行し、整列できることを確認し、その整列時間も確認する。
    また、既に整列されている列を渡した時の挙動も確認し、その解決方法を実装する。

方針:
    まず、前々回の内容を用いて実行時間を測定しつつ実際に実行する。
    恐らく、既に整列されている列をソートした場合ピボットの場所の関係上時間が
    かかることが予想されるので、これを回避するためにピボットの位置を
    要素を３つ比較し、その中央値をピボットの位置とする。

コード:
---------------------------------------------------------------------
// mergesort1demo.c --- demonstration of mergesort1.
// sortdemo.c --- demonstration for basic sort.
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "pqueue.h"

#define MAXDATA 1000000

// #define ENSHU_4_FT
// #define ENSHU_4_ST
 #define ENSHU_4_TT

static int a[MAXDATA];

int *ivec_new(int size) {
  int *a = (int*)malloc((size+1) * sizeof(int));
  a[0] = size; return a;
}
// mergesort=====================================
int *ivec_merge(int *b, int *c) {
  int ib = 1, ic = 1, ia = 1, *a = ivec_new(b[0]+c[0]);
  while(ia <= a[0]) {
    if(ib > b[0])          { a[ia++] = c[ic++]; }
    else if(ic > c[0])     { a[ia++] = b[ib++]; }
    else if(c[ic] < b[ib]) { a[ia++] = c[ic++]; }
    else                   { a[ia++] = b[ib++]; }
  }
  return a;
}

// quicksort=====================================
static void iswap(int *a, int i, int j) {
  int x = a[i]; a[i] = a[j]; a[j] = x;
}

void qs(int *a, int i, int j) {
  if(j <= i) { return; }
  int s = i, pivot = a[j];
  for(int k = i; k < j; ++k) {
    if(a[k] < pivot) { iswap(a, s++, k); }
  }
  iswap(a, j, s); qs(a, i, s-1); qs(a, s+1, j);
}

void quicksort(int *a, int n) { qs(a, 0, n-1); }

// quicksort_adv=================================
int med (int x, int y, int z) {
    if(a[x] > a[y]) {
        if(a[y] > a[z]){ return y; }
        else if(a[z] > a[x]) { return x; }
        else { return z; }
    } else {
        if(a[x] > a[z]) { return x; }
        else if(a[z] > a[y]) { return y; }
        else { return z; }
    }
}
void qs_adv(int* a, int i, int j) {
    if(j <= i) { return; }
    int s = i, pivot = a[med(i, (i+j)/2, j)];
    for(int k = i; k < j; ++k) {
      if(a[k] < pivot) { iswap(a, s++, k); }
    }
    iswap(a, j, s); qs(a, i, s-1); qs(a, s+1, j);
  }

 void quicksort_adv(int *a, int n) { qs_adv(a, 0, n-1); }

// use_queue=====================================
void mergesort1(int *a, int n) {
  pqueuep q = pqueue_new(n+1);
  int *v, *w;
  for(int i = 0; i < n; ++i) {
    v = ivec_new(1); v[1] = a[i]; pqueue_enq(q, v);
  }
  while(true) {
    v = (int*)pqueue_deq(q); if(pqueue_isempty(q)) { break; }
    w = (int*)pqueue_deq(q); pqueue_enq(q, ivec_merge(v, w));
    free(v); free(w);
  }
  for(int i = 0; i < n; ++i) { a[i] = v[i+1]; }
}

// main==========================================
#ifdef ENSHU_4_FT
int main(int argc, char *argv[]) {
  int n = atoi(argv[1]);
  srand(time(NULL));
  struct timespec tm1, tm2;
  for(int i = 0; i < n; ++i) { a[i] = rand()%10000; }
  clock_gettime(CLOCK_REALTIME, &tm1);
  quicksort(a, n);
  clock_gettime(CLOCK_REALTIME, &tm2);
  for(int i = 0; i < n; ++i) { printf(" %d", a[i]); }
  printf("\n");
  double dt = (tm2.tv_sec-tm1.tv_sec) + 1e-9*(tm2.tv_nsec-tm1.tv_nsec);
  printf("time = %.4f\n", dt);
  return 0;
}
#endif
#ifdef ENSHU_4_ST
int main(int argc, char *argv[]) {
  int n = atoi(argv[1]);
  srand(time(NULL));
  struct timespec tm1, tm2;
  for(int i = 0; i < n; ++i) { a[i] = i; }
  clock_gettime(CLOCK_REALTIME, &tm1);
  quicksort(a, n);
  clock_gettime(CLOCK_REALTIME, &tm2);
  for(int i = 0; i < n; ++i) { printf(" %d", a[i]); }
  printf("\n");
  double dt = (tm2.tv_sec-tm1.tv_sec) + 1e-9*(tm2.tv_nsec-tm1.tv_nsec);
  printf("time = %.4f\n", dt);
  return 0;
}
#endif
#ifdef ENSHU_4_TT
int main(int argc, char *argv[]) {
  int n = atoi(argv[1]);
  srand(time(NULL));
  struct timespec tm1, tm2;
  for(int i = 0; i < n; ++i) { a[i] = i; }
  clock_gettime(CLOCK_REALTIME, &tm1);
  quicksort_adv(a, n);
  clock_gettime(CLOCK_REALTIME, &tm2);
  for(int i = 0; i < n; ++i) { printf(" %d", a[i]); }
  printf("\n");
  double dt = (tm2.tv_sec-tm1.tv_sec) + 1e-9*(tm2.tv_nsec-tm1.tv_nsec);
  printf("time = %.4f\n", dt);
  return 0;
}
#endif
---------------------------------------------------------------------
---------------------------------------------------------------------
// pqueue.c --- pointer type queue impl. with array
#include <stdlib.h>
#include "pqueue.h"
struct pqueue { int ip, op, size; void **arr; };
pqueuep pqueue_new(int size) {
  pqueuep p = (pqueuep)malloc(sizeof(struct pqueue));
  p->ip = p->op = 0; p->size = size;
  p->arr = (void**)malloc(size * sizeof(void*)); return p;
}
bool pqueue_isempty(pqueuep p) { return p->ip == p->op; }
bool pqueue_isfull(pqueuep p) { return (p->ip+1)%p->size == p->op; }
void pqueue_enq(pqueuep p, void *v) {
  if(pqueue_isfull(p)) { return; }
  p->arr[p->ip++] = v; if(p->ip >= p->size) { p->ip = 0; }
}
void *pqueue_deq(pqueuep p) {
  if(pqueue_isempty(p)) { return 0; }
  void *v = p->arr[p->op++]; if(p->op >= p->size) { p->op = 0; }
  return v;
}
---------------------------------------------------------------------
---------------------------------------------------------------------
// pqueue.h --- int type queue interface
#include <stdbool.h>
struct pqueue;
typedef struct pqueue *pqueuep;
pqueuep pqueue_new(int size);
bool pqueue_isempty(pqueuep p);
bool pqueue_isfull(pqueuep p);
void pqueue_enq(pqueuep p, void *v);
void *pqueue_deq(pqueuep p);
---------------------------------------------------------------------

実行例:
---------------------------------------------------------------------
---------------------------------------------------------------------
---------------------------------------------------------------------
---------------------------------------------------------------------
---------------------------------------------------------------------
---------------------------------------------------------------------

解説:
    このコードではマクロdefineを用いて実行するテストを変えている。最後がFTのものは
    乱数の数列に単に実行しその時間を計測しただけのものである。また時間計測は第九回のものに則って
    作成してある。
    最後がSTのものは既にソートされた数列に単に実行しその時間を計測したものである。
    最後がTTのものは既にソートされた数列に改善したクイックソートを実行しその時間を計測したものである。
    改善の方法だが、呼び出されたときに指定された数列の範囲内で両端の２つとその中央の１つのなかで
    中央値となる要素をピボットに指定するようにしている。
    この方法を用いることで少なくとも既に整列されている数列に対しては多少の速度の改善が
    なされていることが三回目の実行例にて確認できる。

レビュー課題:
    両端と中央では限定的すぎるから、選択する要素をランダムに取得するのが良いのではないか。

考察:


アンケート: アンケート再掲+回答
